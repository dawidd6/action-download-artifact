{"version":3,"file":"concat.common.js","sourceRoot":"","sources":["../../../src/util/concat.common.ts"],"names":[],"mappings":";AAAA,uCAAuC;AACvC,kCAAkC;;AA0DlC,wBAeC;AAvED,mDAAsD;AAEtD;;;GAGG;AACH,SAAS,KAAK,CAAC,MAAkC;IAC/C,OAAO,IAAI,QAAQ,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,CAAC;AACrC,CAAC;AAED,KAAK,UAAU,UAAU,CACvB,MAAsD;IAEtD,IAAI,MAAM,YAAY,IAAI,IAAI,MAAM,YAAY,UAAU,EAAE,CAAC;QAC3D,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,IAAI,IAAA,mCAAmB,EAAC,MAAM,CAAC,EAAE,CAAC;QAChC,OAAO,KAAK,CAAC,MAAM,CAAC,CAAC;IACvB,CAAC;SAAM,CAAC;QACN,MAAM,IAAI,KAAK,CACb,8FAA8F,CAC/F,CAAC;IACJ,CAAC;AACH,CAAC;AAED;;;;GAIG;AACH,SAAS,kBAAkB,CAAC,MAAkB;IAC5C,IAAI,QAAQ,IAAI,MAAM,CAAC,MAAM,EAAE,CAAC;QAC9B,cAAc;QACd,OAAO,MAAiC,CAAC;IAC3C,CAAC;IACD,oBAAoB;IACpB,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;AAC9B,CAAC;AASD;;;;;;;;GAQG;AACI,KAAK,UAAU,MAAM,CAC1B,OAAgD;IAEhD,MAAM,KAAK,GAAG,EAAE,CAAC;IACjB,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE,CAAC;QAC7B,MAAM,QAAQ,GAAG,MAAM,UAAU,CAAC,OAAO,MAAM,KAAK,UAAU,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QACpF,IAAI,QAAQ,YAAY,IAAI,EAAE,CAAC;YAC7B,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACvB,CAAC;aAAM,CAAC;YACN,aAAa;YACb,KAAK,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;QACvD,CAAC;IACH,CAAC;IAED,OAAO,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC;AACzB,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { isWebReadableStream } from \"./typeGuards.js\";\n\n/**\n * Drain the content of the given ReadableStream into a Blob.\n * The blob's content may end up in memory or on disk dependent on size.\n */\nfunction drain(stream: ReadableStream<Uint8Array>): Promise<Blob> {\n  return new Response(stream).blob();\n}\n\nasync function toBlobPart(\n  source: ReadableStream<Uint8Array> | Blob | Uint8Array,\n): Promise<Blob | Uint8Array> {\n  if (source instanceof Blob || source instanceof Uint8Array) {\n    return source;\n  }\n\n  if (isWebReadableStream(source)) {\n    return drain(source);\n  } else {\n    throw new Error(\n      \"Unsupported source type. Only Blob, Uint8Array, and ReadableStream are supported in browser.\",\n    );\n  }\n}\n\n/**\n * Converts a Uint8Array to a Uint8Array<ArrayBuffer>.\n * @param source - The source Uint8Array.\n * @returns\n */\nfunction arrayToArrayBuffer(source: Uint8Array): Uint8Array<ArrayBuffer> {\n  if (\"resize\" in source.buffer) {\n    // ArrayBuffer\n    return source as Uint8Array<ArrayBuffer>;\n  }\n  // SharedArrayBuffer\n  return source.map((x) => x);\n}\n\n/**\n * Accepted binary data types for concat\n *\n * @internal\n */\ntype ConcatSource = ReadableStream<Uint8Array> | Blob | Uint8Array;\n\n/**\n * Utility function that concatenates a set of binary inputs into one combined output.\n *\n * @param sources - array of sources for the concatenation\n * @returns - in Node, a (() =\\> NodeJS.ReadableStream) which, when read, produces a concatenation of all the inputs.\n *           In browser, returns a `Blob` representing all the concatenated inputs.\n *\n * @internal\n */\nexport async function concat(\n  sources: (ConcatSource | (() => ConcatSource))[],\n): Promise<(() => NodeJS.ReadableStream) | Blob> {\n  const parts = [];\n  for (const source of sources) {\n    const blobPart = await toBlobPart(typeof source === \"function\" ? source() : source);\n    if (blobPart instanceof Blob) {\n      parts.push(blobPart);\n    } else {\n      // Uint8Array\n      parts.push(new Blob([arrayToArrayBuffer(blobPart)]));\n    }\n  }\n\n  return new Blob(parts);\n}\n"]}