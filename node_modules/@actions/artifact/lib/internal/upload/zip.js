var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { realpath } from 'fs/promises';
import archiver from 'archiver';
import * as core from '@actions/core';
import { getUploadChunkSize } from '../shared/config.js';
import { WaterMarkedUploadStream } from './stream.js';
export const DEFAULT_COMPRESSION_LEVEL = 6;
export function createZipUploadStream(uploadSpecification_1) {
    return __awaiter(this, arguments, void 0, function* (uploadSpecification, compressionLevel = DEFAULT_COMPRESSION_LEVEL) {
        core.debug(`Creating Artifact archive with compressionLevel: ${compressionLevel}`);
        const zip = archiver.create('zip', {
            highWaterMark: getUploadChunkSize(),
            zlib: { level: compressionLevel }
        });
        // register callbacks for various events during the zip lifecycle
        zip.on('error', zipErrorCallback);
        zip.on('warning', zipWarningCallback);
        zip.on('finish', zipFinishCallback);
        zip.on('end', zipEndCallback);
        for (const file of uploadSpecification) {
            if (file.sourcePath !== null) {
                // Check if symlink and resolve the source path
                let sourcePath = file.sourcePath;
                if (file.stats.isSymbolicLink()) {
                    sourcePath = yield realpath(file.sourcePath);
                }
                // Add the file to the zip
                zip.file(sourcePath, {
                    name: file.destinationPath
                });
            }
            else {
                // Add a directory to the zip
                zip.append('', { name: file.destinationPath });
            }
        }
        const bufferSize = getUploadChunkSize();
        const zipUploadStream = new WaterMarkedUploadStream(bufferSize);
        core.debug(`Zip write high watermark value ${zipUploadStream.writableHighWaterMark}`);
        core.debug(`Zip read high watermark value ${zipUploadStream.readableHighWaterMark}`);
        zip.pipe(zipUploadStream);
        zip.finalize();
        return zipUploadStream;
    });
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const zipErrorCallback = (error) => {
    core.error('An error has occurred while creating the zip file for upload');
    core.info(error);
    throw new Error('An error has occurred during zip creation for the artifact');
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const zipWarningCallback = (error) => {
    if (error.code === 'ENOENT') {
        core.warning('ENOENT warning during artifact zip creation. No such file or directory');
        core.info(error);
    }
    else {
        core.warning(`A non-blocking warning has occurred during artifact zip creation: ${error.code}`);
        core.info(error);
    }
};
const zipFinishCallback = () => {
    core.debug('Zip stream for upload has finished.');
};
const zipEndCallback = () => {
    core.debug('Zip stream for upload has ended.');
};
//# sourceMappingURL=zip.js.map