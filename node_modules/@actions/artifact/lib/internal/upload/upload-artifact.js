var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as core from '@actions/core';
import * as fs from 'fs';
import * as path from 'path';
import { getExpiration } from './retention.js';
import { validateArtifactName } from './path-and-artifact-name-validation.js';
import { internalArtifactTwirpClient } from '../shared/artifact-twirp-client.js';
import { getUploadZipSpecification, validateRootDirectory } from './upload-zip-specification.js';
import { getBackendIdsFromToken } from '../shared/util.js';
import { uploadToBlobStorage } from './blob-upload.js';
import { createZipUploadStream } from './zip.js';
import { createRawFileUploadStream } from './stream.js';
import { StringValue } from '../../generated/index.js';
import { FilesNotFoundError, InvalidResponseError } from '../shared/errors.js';
import { getMimeType } from './types.js';
export function uploadArtifact(name, files, rootDirectory, options) {
    return __awaiter(this, void 0, void 0, function* () {
        let artifactFileName = `${name}.zip`;
        if (options === null || options === void 0 ? void 0 : options.skipArchive) {
            if (files.length === 0) {
                throw new FilesNotFoundError([]);
            }
            if (files.length > 1) {
                throw new Error('skipArchive option is only supported when uploading a single file');
            }
            if (!fs.existsSync(files[0])) {
                throw new FilesNotFoundError(files);
            }
            artifactFileName = path.basename(files[0]);
            name = artifactFileName;
        }
        validateArtifactName(name);
        validateRootDirectory(rootDirectory);
        let zipSpecification = [];
        if (!(options === null || options === void 0 ? void 0 : options.skipArchive)) {
            zipSpecification = getUploadZipSpecification(files, rootDirectory);
            if (zipSpecification.length === 0) {
                throw new FilesNotFoundError(zipSpecification.flatMap(s => (s.sourcePath ? [s.sourcePath] : [])));
            }
        }
        const contentType = getMimeType(artifactFileName);
        // get the IDs needed for the artifact creation
        const backendIds = getBackendIdsFromToken();
        // create the artifact client
        const artifactClient = internalArtifactTwirpClient();
        // create the artifact
        const createArtifactReq = {
            workflowRunBackendId: backendIds.workflowRunBackendId,
            workflowJobRunBackendId: backendIds.workflowJobRunBackendId,
            name,
            mimeType: StringValue.create({ value: contentType }),
            version: 7
        };
        // if there is a retention period, add it to the request
        const expiresAt = getExpiration(options === null || options === void 0 ? void 0 : options.retentionDays);
        if (expiresAt) {
            createArtifactReq.expiresAt = expiresAt;
        }
        const createArtifactResp = yield artifactClient.CreateArtifact(createArtifactReq);
        if (!createArtifactResp.ok) {
            throw new InvalidResponseError('CreateArtifact: response from backend was not ok');
        }
        let stream;
        if (options === null || options === void 0 ? void 0 : options.skipArchive) {
            // Upload raw file without archiving
            stream = yield createRawFileUploadStream(files[0]);
        }
        else {
            // Create and upload zip archive
            stream = yield createZipUploadStream(zipSpecification, options === null || options === void 0 ? void 0 : options.compressionLevel);
        }
        core.info(`Uploading artifact: ${artifactFileName}`);
        const uploadResult = yield uploadToBlobStorage(createArtifactResp.signedUploadUrl, stream, contentType);
        // finalize the artifact
        const finalizeArtifactReq = {
            workflowRunBackendId: backendIds.workflowRunBackendId,
            workflowJobRunBackendId: backendIds.workflowJobRunBackendId,
            name,
            size: uploadResult.uploadSize ? uploadResult.uploadSize.toString() : '0'
        };
        if (uploadResult.sha256Hash) {
            finalizeArtifactReq.hash = StringValue.create({
                value: `sha256:${uploadResult.sha256Hash}`
            });
        }
        core.info(`Finalizing artifact upload`);
        const finalizeArtifactResp = yield artifactClient.FinalizeArtifact(finalizeArtifactReq);
        if (!finalizeArtifactResp.ok) {
            throw new InvalidResponseError('FinalizeArtifact: response from backend was not ok');
        }
        const artifactId = BigInt(finalizeArtifactResp.artifactId);
        core.info(`Artifact ${name} successfully finalized. Artifact ID ${artifactId}`);
        return {
            size: uploadResult.uploadSize,
            digest: uploadResult.sha256Hash,
            id: Number(artifactId)
        };
    });
}
//# sourceMappingURL=upload-artifact.js.map