var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { getOctokit } from '@actions/github';
import { retry } from '@octokit/plugin-retry';
import * as core from '@actions/core';
import { defaults as defaultGitHubOptions } from '@actions/github/lib/utils';
import { getRetryOptions } from './retry-options.js';
import { requestLog } from '@octokit/plugin-request-log';
import { getBackendIdsFromToken } from '../shared/util.js';
import { getUserAgentString } from '../shared/user-agent.js';
import { internalArtifactTwirpClient } from '../shared/artifact-twirp-client.js';
import { StringValue, Timestamp } from '../../generated/index.js';
import { ArtifactNotFoundError, InvalidResponseError } from '../shared/errors.js';
export function getArtifactPublic(artifactName, workflowRunId, repositoryOwner, repositoryName, token) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const [retryOpts, requestOpts] = getRetryOptions(defaultGitHubOptions);
        const opts = {
            log: undefined,
            userAgent: getUserAgentString(),
            previews: undefined,
            retry: retryOpts,
            request: requestOpts
        };
        const github = getOctokit(token, opts, retry, requestLog);
        const getArtifactResp = yield github.request('GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts{?name}', {
            owner: repositoryOwner,
            repo: repositoryName,
            run_id: workflowRunId,
            name: artifactName
        });
        if (getArtifactResp.status !== 200) {
            throw new InvalidResponseError(`Invalid response from GitHub API: ${getArtifactResp.status} (${(_a = getArtifactResp === null || getArtifactResp === void 0 ? void 0 : getArtifactResp.headers) === null || _a === void 0 ? void 0 : _a['x-github-request-id']})`);
        }
        if (getArtifactResp.data.artifacts.length === 0) {
            throw new ArtifactNotFoundError(`Artifact not found for name: ${artifactName}
        Please ensure that your artifact is not expired and the artifact was uploaded using a compatible version of toolkit/upload-artifact.
        For more information, visit the GitHub Artifacts FAQ: https://github.com/actions/toolkit/blob/main/packages/artifact/docs/faq.md`);
        }
        let artifact = getArtifactResp.data.artifacts[0];
        if (getArtifactResp.data.artifacts.length > 1) {
            artifact = getArtifactResp.data.artifacts.sort((a, b) => b.id - a.id)[0];
            core.debug(`More than one artifact found for a single name, returning newest (id: ${artifact.id})`);
        }
        return {
            artifact: {
                name: artifact.name,
                id: artifact.id,
                size: artifact.size_in_bytes,
                createdAt: artifact.created_at
                    ? new Date(artifact.created_at)
                    : undefined,
                digest: artifact.digest
            }
        };
    });
}
export function getArtifactInternal(artifactName) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        const artifactClient = internalArtifactTwirpClient();
        const { workflowRunBackendId, workflowJobRunBackendId } = getBackendIdsFromToken();
        const req = {
            workflowRunBackendId,
            workflowJobRunBackendId,
            nameFilter: StringValue.create({ value: artifactName })
        };
        const res = yield artifactClient.ListArtifacts(req);
        if (res.artifacts.length === 0) {
            throw new ArtifactNotFoundError(`Artifact not found for name: ${artifactName}
        Please ensure that your artifact is not expired and the artifact was uploaded using a compatible version of toolkit/upload-artifact.
        For more information, visit the GitHub Artifacts FAQ: https://github.com/actions/toolkit/blob/main/packages/artifact/docs/faq.md`);
        }
        let artifact = res.artifacts[0];
        if (res.artifacts.length > 1) {
            artifact = res.artifacts.sort((a, b) => Number(b.databaseId) - Number(a.databaseId))[0];
            core.debug(`More than one artifact found for a single name, returning newest (id: ${artifact.databaseId})`);
        }
        return {
            artifact: {
                name: artifact.name,
                id: Number(artifact.databaseId),
                size: Number(artifact.size),
                createdAt: artifact.createdAt
                    ? Timestamp.toDate(artifact.createdAt)
                    : undefined,
                digest: (_a = artifact.digest) === null || _a === void 0 ? void 0 : _a.value
            }
        };
    });
}
//# sourceMappingURL=get-artifact.js.map