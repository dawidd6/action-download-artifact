var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { info, warning, debug } from '@actions/core';
import { getOctokit } from '@actions/github';
import { getUserAgentString } from '../shared/user-agent.js';
import { getRetryOptions } from './retry-options.js';
import { defaults as defaultGitHubOptions } from '@actions/github/lib/utils';
import { requestLog } from '@octokit/plugin-request-log';
import { retry } from '@octokit/plugin-retry';
import { internalArtifactTwirpClient } from '../shared/artifact-twirp-client.js';
import { getBackendIdsFromToken } from '../shared/util.js';
import { getMaxArtifactListCount } from '../shared/config.js';
import { Timestamp } from '../../generated/index.js';
const maximumArtifactCount = getMaxArtifactListCount();
const paginationCount = 100;
const maxNumberOfPages = Math.ceil(maximumArtifactCount / paginationCount);
export function listArtifactsPublic(workflowRunId_1, repositoryOwner_1, repositoryName_1, token_1) {
    return __awaiter(this, arguments, void 0, function* (workflowRunId, repositoryOwner, repositoryName, token, latest = false) {
        info(`Fetching artifact list for workflow run ${workflowRunId} in repository ${repositoryOwner}/${repositoryName}`);
        let artifacts = [];
        const [retryOpts, requestOpts] = getRetryOptions(defaultGitHubOptions);
        const opts = {
            log: undefined,
            userAgent: getUserAgentString(),
            previews: undefined,
            retry: retryOpts,
            request: requestOpts
        };
        const github = getOctokit(token, opts, retry, requestLog);
        let currentPageNumber = 1;
        const { data: listArtifactResponse } = yield github.request('GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts', {
            owner: repositoryOwner,
            repo: repositoryName,
            run_id: workflowRunId,
            per_page: paginationCount,
            page: currentPageNumber
        });
        let numberOfPages = Math.ceil(listArtifactResponse.total_count / paginationCount);
        const totalArtifactCount = listArtifactResponse.total_count;
        if (totalArtifactCount > maximumArtifactCount) {
            warning(`Workflow run ${workflowRunId} has ${totalArtifactCount} artifacts, exceeding the limit of ${maximumArtifactCount}. Results will be incomplete as only the first ${maximumArtifactCount} artifacts will be returned`);
            numberOfPages = maxNumberOfPages;
        }
        // Iterate over the first page
        for (const artifact of listArtifactResponse.artifacts) {
            artifacts.push({
                name: artifact.name,
                id: artifact.id,
                size: artifact.size_in_bytes,
                createdAt: artifact.created_at
                    ? new Date(artifact.created_at)
                    : undefined,
                digest: artifact.digest
            });
        }
        // Move to the next page
        currentPageNumber++;
        // Iterate over any remaining pages
        for (currentPageNumber; currentPageNumber <= numberOfPages; currentPageNumber++) {
            debug(`Fetching page ${currentPageNumber} of artifact list`);
            const { data: listArtifactResponse } = yield github.request('GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts', {
                owner: repositoryOwner,
                repo: repositoryName,
                run_id: workflowRunId,
                per_page: paginationCount,
                page: currentPageNumber
            });
            for (const artifact of listArtifactResponse.artifacts) {
                artifacts.push({
                    name: artifact.name,
                    id: artifact.id,
                    size: artifact.size_in_bytes,
                    createdAt: artifact.created_at
                        ? new Date(artifact.created_at)
                        : undefined,
                    digest: artifact.digest
                });
            }
        }
        if (latest) {
            artifacts = filterLatest(artifacts);
        }
        info(`Found ${artifacts.length} artifact(s)`);
        return {
            artifacts
        };
    });
}
export function listArtifactsInternal() {
    return __awaiter(this, arguments, void 0, function* (latest = false) {
        const artifactClient = internalArtifactTwirpClient();
        const { workflowRunBackendId, workflowJobRunBackendId } = getBackendIdsFromToken();
        const req = {
            workflowRunBackendId,
            workflowJobRunBackendId
        };
        const res = yield artifactClient.ListArtifacts(req);
        let artifacts = res.artifacts.map(artifact => {
            var _a;
            return ({
                name: artifact.name,
                id: Number(artifact.databaseId),
                size: Number(artifact.size),
                createdAt: artifact.createdAt
                    ? Timestamp.toDate(artifact.createdAt)
                    : undefined,
                digest: (_a = artifact.digest) === null || _a === void 0 ? void 0 : _a.value
            });
        });
        if (latest) {
            artifacts = filterLatest(artifacts);
        }
        info(`Found ${artifacts.length} artifact(s)`);
        return {
            artifacts
        };
    });
}
/**
 * Filters a list of artifacts to only include the latest artifact for each name
 * @param artifacts The artifacts to filter
 * @returns The filtered list of artifacts
 */
function filterLatest(artifacts) {
    artifacts.sort((a, b) => b.id - a.id);
    const latestArtifacts = [];
    const seenArtifactNames = new Set();
    for (const artifact of artifacts) {
        if (!seenArtifactNames.has(artifact.name)) {
            latestArtifacts.push(artifact);
            seenArtifactNames.add(artifact.name);
        }
    }
    return latestArtifacts;
}
//# sourceMappingURL=list-artifacts.js.map