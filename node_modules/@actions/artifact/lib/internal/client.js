var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { warning } from '@actions/core';
import { isGhes } from './shared/config.js';
import { uploadArtifact } from './upload/upload-artifact.js';
import { downloadArtifactPublic, downloadArtifactInternal } from './download/download-artifact.js';
import { deleteArtifactPublic, deleteArtifactInternal } from './delete/delete-artifact.js';
import { getArtifactPublic, getArtifactInternal } from './find/get-artifact.js';
import { listArtifactsPublic, listArtifactsInternal } from './find/list-artifacts.js';
import { GHESNotSupportedError } from './shared/errors.js';
/**
 * The default artifact client that is used by the artifact action(s).
 */
export class DefaultArtifactClient {
    uploadArtifact(name, files, rootDirectory, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (isGhes()) {
                    throw new GHESNotSupportedError();
                }
                return uploadArtifact(name, files, rootDirectory, options);
            }
            catch (error) {
                warning(`Artifact upload failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions is operating normally at [https://githubstatus.com](https://www.githubstatus.com).`);
                throw error;
            }
        });
    }
    downloadArtifact(artifactId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (isGhes()) {
                    throw new GHESNotSupportedError();
                }
                if (options === null || options === void 0 ? void 0 : options.findBy) {
                    const { findBy: { repositoryOwner, repositoryName, token } } = options, downloadOptions = __rest(options, ["findBy"]);
                    return downloadArtifactPublic(artifactId, repositoryOwner, repositoryName, token, downloadOptions);
                }
                return downloadArtifactInternal(artifactId, options);
            }
            catch (error) {
                warning(`Download Artifact failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions and API requests are operating normally at [https://githubstatus.com](https://www.githubstatus.com).`);
                throw error;
            }
        });
    }
    listArtifacts(options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (isGhes()) {
                    throw new GHESNotSupportedError();
                }
                if (options === null || options === void 0 ? void 0 : options.findBy) {
                    const { findBy: { workflowRunId, repositoryOwner, repositoryName, token } } = options;
                    return listArtifactsPublic(workflowRunId, repositoryOwner, repositoryName, token, options === null || options === void 0 ? void 0 : options.latest);
                }
                return listArtifactsInternal(options === null || options === void 0 ? void 0 : options.latest);
            }
            catch (error) {
                warning(`Listing Artifacts failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions and API requests are operating normally at [https://githubstatus.com](https://www.githubstatus.com).`);
                throw error;
            }
        });
    }
    getArtifact(artifactName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (isGhes()) {
                    throw new GHESNotSupportedError();
                }
                if (options === null || options === void 0 ? void 0 : options.findBy) {
                    const { findBy: { workflowRunId, repositoryOwner, repositoryName, token } } = options;
                    return getArtifactPublic(artifactName, workflowRunId, repositoryOwner, repositoryName, token);
                }
                return getArtifactInternal(artifactName);
            }
            catch (error) {
                warning(`Get Artifact failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions and API requests are operating normally at [https://githubstatus.com](https://www.githubstatus.com).`);
                throw error;
            }
        });
    }
    deleteArtifact(artifactName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (isGhes()) {
                    throw new GHESNotSupportedError();
                }
                if (options === null || options === void 0 ? void 0 : options.findBy) {
                    const { findBy: { repositoryOwner, repositoryName, workflowRunId, token } } = options;
                    return deleteArtifactPublic(artifactName, workflowRunId, repositoryOwner, repositoryName, token);
                }
                return deleteArtifactInternal(artifactName);
            }
            catch (error) {
                warning(`Delete Artifact failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions and API requests are operating normally at [https://githubstatus.com](https://www.githubstatus.com).`);
                throw error;
            }
        });
    }
}
//# sourceMappingURL=client.js.map