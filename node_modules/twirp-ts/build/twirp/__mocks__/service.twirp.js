"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHaberdasherServer = exports.HaberdasherMethodList = exports.HaberdasherMethod = exports.HaberdasherClientProtobuf = exports.HaberdasherClientJSON = void 0;
const index_1 = require("../index");
const service_1 = require("./service");
class HaberdasherClientJSON {
    constructor(rpc) {
        this.rpc = rpc;
        this.MakeHat.bind(this);
        this.FindHat.bind(this);
        this.ListHat.bind(this);
    }
    MakeHat(request) {
        const data = service_1.Size.toJson(request, {
            useProtoFieldName: true,
            emitDefaultValues: false,
        });
        const promise = this.rpc.request("twirp.example.haberdasher.Haberdasher", "MakeHat", "application/json", data);
        return promise.then((data) => service_1.Hat.fromJson(data, { ignoreUnknownFields: true }));
    }
    FindHat(request) {
        const data = service_1.FindHatRPC.toJson(request, {
            useProtoFieldName: true,
            emitDefaultValues: false,
        });
        const promise = this.rpc.request("twirp.example.haberdasher.Haberdasher", "FindHat", "application/json", data);
        return promise.then((data) => service_1.FindHatRPC.fromJson(data, { ignoreUnknownFields: true }));
    }
    ListHat(request) {
        const data = service_1.ListHatRPC.toJson(request, {
            useProtoFieldName: true,
            emitDefaultValues: false,
        });
        const promise = this.rpc.request("twirp.example.haberdasher.Haberdasher", "ListHat", "application/json", data);
        return promise.then((data) => service_1.ListHatRPC.fromJson(data, { ignoreUnknownFields: true }));
    }
}
exports.HaberdasherClientJSON = HaberdasherClientJSON;
class HaberdasherClientProtobuf {
    constructor(rpc) {
        this.rpc = rpc;
        this.MakeHat.bind(this);
        this.FindHat.bind(this);
        this.ListHat.bind(this);
    }
    MakeHat(request) {
        const data = service_1.Size.toBinary(request);
        const promise = this.rpc.request("twirp.example.haberdasher.Haberdasher", "MakeHat", "application/protobuf", data);
        return promise.then((data) => service_1.Hat.fromBinary(data));
    }
    FindHat(request) {
        const data = service_1.FindHatRPC.toBinary(request);
        const promise = this.rpc.request("twirp.example.haberdasher.Haberdasher", "FindHat", "application/protobuf", data);
        return promise.then((data) => service_1.FindHatRPC.fromBinary(data));
    }
    ListHat(request) {
        const data = service_1.ListHatRPC.toBinary(request);
        const promise = this.rpc.request("twirp.example.haberdasher.Haberdasher", "ListHat", "application/protobuf", data);
        return promise.then((data) => service_1.ListHatRPC.fromBinary(data));
    }
}
exports.HaberdasherClientProtobuf = HaberdasherClientProtobuf;
var HaberdasherMethod;
(function (HaberdasherMethod) {
    HaberdasherMethod["MakeHat"] = "MakeHat";
    HaberdasherMethod["FindHat"] = "FindHat";
    HaberdasherMethod["ListHat"] = "ListHat";
})(HaberdasherMethod = exports.HaberdasherMethod || (exports.HaberdasherMethod = {}));
exports.HaberdasherMethodList = [
    HaberdasherMethod.MakeHat,
    HaberdasherMethod.FindHat,
    HaberdasherMethod.ListHat,
];
function createHaberdasherServer(service) {
    return new index_1.TwirpServer({
        service,
        packageName: "twirp.example.haberdasher",
        serviceName: "Haberdasher",
        methodList: exports.HaberdasherMethodList,
        matchRoute: matchHaberdasherRoute,
    });
}
exports.createHaberdasherServer = createHaberdasherServer;
function matchHaberdasherRoute(method, events) {
    switch (method) {
        case "MakeHat":
            return (ctx, service, data, interceptors) => __awaiter(this, void 0, void 0, function* () {
                ctx = Object.assign(Object.assign({}, ctx), { methodName: "MakeHat" });
                yield events.onMatch(ctx);
                return handleHaberdasherMakeHatRequest(ctx, service, data, interceptors);
            });
        case "FindHat":
            return (ctx, service, data, interceptors) => __awaiter(this, void 0, void 0, function* () {
                ctx = Object.assign(Object.assign({}, ctx), { methodName: "FindHat" });
                yield events.onMatch(ctx);
                return handleHaberdasherFindHatRequest(ctx, service, data, interceptors);
            });
        case "ListHat":
            return (ctx, service, data, interceptors) => __awaiter(this, void 0, void 0, function* () {
                ctx = Object.assign(Object.assign({}, ctx), { methodName: "ListHat" });
                yield events.onMatch(ctx);
                return handleHaberdasherListHatRequest(ctx, service, data, interceptors);
            });
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new index_1.TwirpError(index_1.TwirpErrorCode.BadRoute, msg);
    }
}
function handleHaberdasherMakeHatRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case index_1.TwirpContentType.JSON:
            return handleHaberdasherMakeHatJSON(ctx, service, data, interceptors);
        case index_1.TwirpContentType.Protobuf:
            return handleHaberdasherMakeHatProtobuf(ctx, service, data, interceptors);
        default:
            const msg = "unexpected Content-Type";
            throw new index_1.TwirpError(index_1.TwirpErrorCode.BadRoute, msg);
    }
}
function handleHaberdasherFindHatRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case index_1.TwirpContentType.JSON:
            return handleHaberdasherFindHatJSON(ctx, service, data, interceptors);
        case index_1.TwirpContentType.Protobuf:
            return handleHaberdasherFindHatProtobuf(ctx, service, data, interceptors);
        default:
            const msg = "unexpected Content-Type";
            throw new index_1.TwirpError(index_1.TwirpErrorCode.BadRoute, msg);
    }
}
function handleHaberdasherListHatRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case index_1.TwirpContentType.JSON:
            return handleHaberdasherListHatJSON(ctx, service, data, interceptors);
        case index_1.TwirpContentType.Protobuf:
            return handleHaberdasherListHatProtobuf(ctx, service, data, interceptors);
        default:
            const msg = "unexpected Content-Type";
            throw new index_1.TwirpError(index_1.TwirpErrorCode.BadRoute, msg);
    }
}
function handleHaberdasherMakeHatJSON(ctx, service, data, interceptors) {
    return __awaiter(this, void 0, void 0, function* () {
        let request;
        let response;
        try {
            const body = JSON.parse(data.toString() || "{}");
            request = service_1.Size.fromJson(body, { ignoreUnknownFields: true });
        }
        catch (e) {
            if (e instanceof Error) {
                const msg = "the json request could not be decoded";
                throw new index_1.TwirpError(index_1.TwirpErrorCode.Malformed, msg).withCause(e, true);
            }
        }
        if (interceptors && interceptors.length > 0) {
            const interceptor = index_1.chainInterceptors(...interceptors);
            response = yield interceptor(ctx, request, (ctx, inputReq) => {
                return service.MakeHat(ctx, inputReq);
            });
        }
        else {
            response = yield service.MakeHat(ctx, request);
        }
        return JSON.stringify(service_1.Hat.toJson(response, {
            useProtoFieldName: true,
            emitDefaultValues: false,
        }));
    });
}
function handleHaberdasherFindHatJSON(ctx, service, data, interceptors) {
    return __awaiter(this, void 0, void 0, function* () {
        let request;
        let response;
        try {
            const body = JSON.parse(data.toString() || "{}");
            request = service_1.FindHatRPC.fromJson(body, { ignoreUnknownFields: true });
        }
        catch (e) {
            if (e instanceof Error) {
                const msg = "the json request could not be decoded";
                throw new index_1.TwirpError(index_1.TwirpErrorCode.Malformed, msg).withCause(e, true);
            }
        }
        if (interceptors && interceptors.length > 0) {
            const interceptor = index_1.chainInterceptors(...interceptors);
            response = yield interceptor(ctx, request, (ctx, inputReq) => {
                return service.FindHat(ctx, inputReq);
            });
        }
        else {
            response = yield service.FindHat(ctx, request);
        }
        return JSON.stringify(service_1.FindHatRPC.toJson(response, {
            useProtoFieldName: true,
            emitDefaultValues: false,
        }));
    });
}
function handleHaberdasherListHatJSON(ctx, service, data, interceptors) {
    return __awaiter(this, void 0, void 0, function* () {
        let request;
        let response;
        try {
            const body = JSON.parse(data.toString() || "{}");
            request = service_1.ListHatRPC.fromJson(body, { ignoreUnknownFields: true });
        }
        catch (e) {
            if (e instanceof Error) {
                const msg = "the json request could not be decoded";
                throw new index_1.TwirpError(index_1.TwirpErrorCode.Malformed, msg).withCause(e, true);
            }
        }
        if (interceptors && interceptors.length > 0) {
            const interceptor = index_1.chainInterceptors(...interceptors);
            response = yield interceptor(ctx, request, (ctx, inputReq) => {
                return service.ListHat(ctx, inputReq);
            });
        }
        else {
            response = yield service.ListHat(ctx, request);
        }
        return JSON.stringify(service_1.ListHatRPC.toJson(response, {
            useProtoFieldName: true,
            emitDefaultValues: false,
        }));
    });
}
function handleHaberdasherMakeHatProtobuf(ctx, service, data, interceptors) {
    return __awaiter(this, void 0, void 0, function* () {
        let request;
        let response;
        try {
            request = service_1.Size.fromBinary(data);
        }
        catch (e) {
            if (e instanceof Error) {
                const msg = "the protobuf request could not be decoded";
                throw new index_1.TwirpError(index_1.TwirpErrorCode.Malformed, msg).withCause(e, true);
            }
        }
        if (interceptors && interceptors.length > 0) {
            const interceptor = index_1.chainInterceptors(...interceptors);
            response = yield interceptor(ctx, request, (ctx, inputReq) => {
                return service.MakeHat(ctx, inputReq);
            });
        }
        else {
            response = yield service.MakeHat(ctx, request);
        }
        return Buffer.from(service_1.Hat.toBinary(response));
    });
}
function handleHaberdasherFindHatProtobuf(ctx, service, data, interceptors) {
    return __awaiter(this, void 0, void 0, function* () {
        let request;
        let response;
        try {
            request = service_1.FindHatRPC.fromBinary(data);
        }
        catch (e) {
            if (e instanceof Error) {
                const msg = "the protobuf request could not be decoded";
                throw new index_1.TwirpError(index_1.TwirpErrorCode.Malformed, msg).withCause(e, true);
            }
        }
        if (interceptors && interceptors.length > 0) {
            const interceptor = index_1.chainInterceptors(...interceptors);
            response = yield interceptor(ctx, request, (ctx, inputReq) => {
                return service.FindHat(ctx, inputReq);
            });
        }
        else {
            response = yield service.FindHat(ctx, request);
        }
        return Buffer.from(service_1.FindHatRPC.toBinary(response));
    });
}
function handleHaberdasherListHatProtobuf(ctx, service, data, interceptors) {
    return __awaiter(this, void 0, void 0, function* () {
        let request;
        let response;
        try {
            request = service_1.ListHatRPC.fromBinary(data);
        }
        catch (e) {
            if (e instanceof Error) {
                const msg = "the protobuf request could not be decoded";
                throw new index_1.TwirpError(index_1.TwirpErrorCode.Malformed, msg).withCause(e, true);
            }
        }
        if (interceptors && interceptors.length > 0) {
            const interceptor = index_1.chainInterceptors(...interceptors);
            response = yield interceptor(ctx, request, (ctx, inputReq) => {
                return service.ListHat(ctx, inputReq);
            });
        }
        else {
            response = yield service.ListHat(ctx, request);
        }
        return Buffer.from(service_1.ListHatRPC.toBinary(response));
    });
}
